{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"opentracing-decorator - A Python decorator for OpenTracing trace generation. Opentracing Decorator is a small Python library that adds a convenient decorator for generating OpenTracing traces. It works with any client implementation that follows the OpenTracing standard. Note : Opentracing Decorator is in early beta. Use in production at your own risk. Although the library is small and quite stable, some bugs arising from edge cases should be expected. Let's get started... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # examples/simple.py import time from jaeger_client import Config from opentracing_decorator import Tracing # No sampler host and port specified because the Jaeger client picks localhost:6831 by default. config = Config ( config = { \"sampler\" : { \"type\" : \"const\" , # Not advised to have constant sampling in production. \"param\" : 1 , }, \"logging\" : True , }, service_name = \"example-service\" , validate = True , ) jaeger_tracer = config . initialize_tracer () # Pass in an instance of a tracer implementation. # Here, we're using the Jaeger client. tracing = Tracing ( tracer = jaeger_tracer ) # Decorate functions with the @tracing.trace decorator and an operation_name. @tracing . trace ( operation_name = \"MyOperationName\" ) def do_some_work ( x , y , z ): return x + y + z if __name__ == \"__main__\" : do_some_work ( 10 , 20 , 30 ) # Give some time to report traces. time . sleep ( 5 ) jaeger_tracer . close () More information about getting started and enabling different features can be found on the Quickstart page. Features Automatic Span tagging of function parameters (Opt-In). Automatic Span logging of function return values (Opt-In). Works with any OpenTracing compatible tracing client. Jaeger Zipkin Installation Install with pip: 1 $ pip install opentracing-decorator Opentracing Decorator requires Python 3.6+. Documentation Project documentation is available at https://doughepi.github.io/opentracing-decorator/ . For a run-through of all the basics, head over to the QuickStart . The Developer Interface provides a comprehensive API reference. To learn more about the OpenTracing standards, check out The OpenTracing Project Contribute If you want to contribute to Opentracing Decorator check out the Contributing Guide to learn how to start. Dependencies The Opentracing Decorator project relies on these excellent libraries: opentracing - The no-op implementation of the OpenTracing standard. flatten-dict - To support some of the parameter tagging and return logging. \u2014 \u2b50\ufe0f \u2014 Opentracing Decorator is MIT licensed code. Designed & built in Minneapolis, MN. Used at General Mills.","title":"Introduction"},{"location":"#features","text":"Automatic Span tagging of function parameters (Opt-In). Automatic Span logging of function return values (Opt-In). Works with any OpenTracing compatible tracing client. Jaeger Zipkin","title":"Features"},{"location":"#installation","text":"Install with pip: 1 $ pip install opentracing-decorator Opentracing Decorator requires Python 3.6+.","title":"Installation"},{"location":"#documentation","text":"Project documentation is available at https://doughepi.github.io/opentracing-decorator/ . For a run-through of all the basics, head over to the QuickStart . The Developer Interface provides a comprehensive API reference. To learn more about the OpenTracing standards, check out The OpenTracing Project","title":"Documentation"},{"location":"#contribute","text":"If you want to contribute to Opentracing Decorator check out the Contributing Guide to learn how to start.","title":"Contribute"},{"location":"#dependencies","text":"The Opentracing Decorator project relies on these excellent libraries: opentracing - The no-op implementation of the OpenTracing standard. flatten-dict - To support some of the parameter tagging and return logging. \u2014 \u2b50\ufe0f \u2014 Opentracing Decorator is MIT licensed code. Designed & built in Minneapolis, MN. Used at General Mills.","title":"Dependencies"},{"location":"api/","text":"API Tracing class opentracing_decorator. Tracing ( tracer=None ) trace ( self , operation_name , func=None , * , pass_span=False , tag_parameters=False , parameter_prefix=None , flatten_parameters=True , parameter_reducer='dot' , log_return=False , return_prefix='return' , flatten_return=True , return_reducer='dot' )","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#tracing","text":"class opentracing_decorator. Tracing ( tracer=None ) trace ( self , operation_name , func=None , * , pass_span=False , tag_parameters=False , parameter_prefix=None , flatten_parameters=True , parameter_reducer='dot' , log_return=False , return_prefix='return' , flatten_return=True , return_reducer='dot' )","title":"Tracing"},{"location":"quickstart/","text":"Quickstart Simple Tracing Get the package from PyPI. 1 pip install opentracing-decorator Import and define an instance of the Opentracing Decorator class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # examples/simple.py import time from jaeger_client import Config from opentracing_decorator import Tracing # No sampler host and port specified because the Jaeger client picks localhost:6831 by default. config = Config ( config = { \"sampler\" : { \"type\" : \"const\" , # Not advised to have constant sampling in production. \"param\" : 1 , }, \"logging\" : True , }, service_name = \"example-service\" , validate = True , ) jaeger_tracer = config . initialize_tracer () # Pass in an instance of a tracer implementation. # Here, we're using the Jaeger client. tracing = Tracing ( tracer = jaeger_tracer ) Here, we're using the Jaeger implementation of OpenTracing for integration with the Jaeger tracing system. You can use any OpenTracing compatible tracer. For example, the Zipkin OpenTracing client I can now annotate any function I want, in order to start generating and pushing traces to the Jaeger server. 1 2 3 4 5 # examples/simple.py @tracing . trace ( operation_name = \"MyOperationName\" ) def do_some_work ( x , y , z ): return x + y + z Be sure to give the tracer time to report traces so it can clear its buffers before exiting. Although, the worst thing that could happen if you forget this is that some of your traces will not show up. 1 2 3 4 5 6 7 8 # examples/simple.py if __name__ == \"__main__\" : do_some_work ( 10 , 20 , 30 ) # Give some time to report traces. time . sleep ( 5 ) jaeger_tracer . close () At this point, you should see traces start to show up in the user interface. Obtain Span Reference It's generally helpful to access the active Span while doing any sort of processing. This is so that you can do things like add tags, log arbitrary key/value information, etc. You can configure the Opentracing Decorator to pass a reference to the Span you are within by passing the pass_span=True argument to the decorator. 1 2 3 4 5 6 @tracing . trace ( operation_name = \"MyOperationName\" , pass_span = True ) def do_some_work ( x , y , z , span ): span . set_tag ( \"x\" , x ) value = x + y + z span . log_kv ({ \"value\" : value }) return value If you only desire access to the Span to tag function parameters and log function return values--take a look at the automatic parameter tagging feature for an easier way to do this. Automatic Parameter Tagging Enabling parameter tagging You can configure the Opentracing Decorator to automatically tag function Spans with the names and values of the function arguments. To clarify, if we have a function like this 1 2 3 @tracing . trace ( operation_name = \"GetData\" ) def get_data ( method , url , headers = {}): return requests . request ( method , url , headers = headers ) we may want to see the values for method , url , and headers in our Span tags. Simply set the tag_parameters flag on the decorator. 1 2 3 4 5 # examples/automatic_parameter_tagging.py @tracing . trace ( operation_name = \"GetData\" , tag_parameters = True ) def get_data ( method , url , headers = {}): return requests . request ( method , url , headers = headers ) Now our function parameters are tagged and added to the span. Adding a tag prefix You can set a tag prefix by using the parameter_prefix argument to the decorator. 1 2 3 @tracing . trace ( operation_name = \"GetData\" , tag_parameters = True , parameter_prefix = 'devops' ) def get_data ( method , url , headers = {}): return requests . request ( method , url , headers = headers ) This will put devops.* in front of every automatically tagged parameter. This is useful for avoiding collisions with tags from other applications. Automatic Return Value Logging Enabling return value logging You can configure the Opentracing Decorator to automatically log function return values to the Span. To clarify, if we have a function like this 1 2 3 @tracing . trace ( operation_name = \"GetData\" ) def get_data ( method , url , headers = {}): return requests . request ( method , url , headers = headers ) we may want to see log the return value from the api request to our Span for future analysis. Simply set the tag_parameters flag on the decorator. 1 2 3 4 5 # examples/automatic_return_value_logging.py @tracing . trace ( operation_name = \"GetTime\" , log_return = True ) def get_time (): return time . time () Now our function return value is logged to the Span. Adding a return prefix You can set a return prefix by using the return_prefix argument to the decorator. 1 2 3 @tracing . trace ( operation_name = \"GetTime\" , log_return = True , return_prefix = 'devops.return' ) def get_time (): return time . time ()","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#simple-tracing","text":"Get the package from PyPI. 1 pip install opentracing-decorator Import and define an instance of the Opentracing Decorator class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # examples/simple.py import time from jaeger_client import Config from opentracing_decorator import Tracing # No sampler host and port specified because the Jaeger client picks localhost:6831 by default. config = Config ( config = { \"sampler\" : { \"type\" : \"const\" , # Not advised to have constant sampling in production. \"param\" : 1 , }, \"logging\" : True , }, service_name = \"example-service\" , validate = True , ) jaeger_tracer = config . initialize_tracer () # Pass in an instance of a tracer implementation. # Here, we're using the Jaeger client. tracing = Tracing ( tracer = jaeger_tracer ) Here, we're using the Jaeger implementation of OpenTracing for integration with the Jaeger tracing system. You can use any OpenTracing compatible tracer. For example, the Zipkin OpenTracing client I can now annotate any function I want, in order to start generating and pushing traces to the Jaeger server. 1 2 3 4 5 # examples/simple.py @tracing . trace ( operation_name = \"MyOperationName\" ) def do_some_work ( x , y , z ): return x + y + z Be sure to give the tracer time to report traces so it can clear its buffers before exiting. Although, the worst thing that could happen if you forget this is that some of your traces will not show up. 1 2 3 4 5 6 7 8 # examples/simple.py if __name__ == \"__main__\" : do_some_work ( 10 , 20 , 30 ) # Give some time to report traces. time . sleep ( 5 ) jaeger_tracer . close () At this point, you should see traces start to show up in the user interface.","title":"Simple Tracing"},{"location":"quickstart/#obtain-span-reference","text":"It's generally helpful to access the active Span while doing any sort of processing. This is so that you can do things like add tags, log arbitrary key/value information, etc. You can configure the Opentracing Decorator to pass a reference to the Span you are within by passing the pass_span=True argument to the decorator. 1 2 3 4 5 6 @tracing . trace ( operation_name = \"MyOperationName\" , pass_span = True ) def do_some_work ( x , y , z , span ): span . set_tag ( \"x\" , x ) value = x + y + z span . log_kv ({ \"value\" : value }) return value If you only desire access to the Span to tag function parameters and log function return values--take a look at the automatic parameter tagging feature for an easier way to do this.","title":"Obtain Span Reference"},{"location":"quickstart/#automatic-parameter-tagging","text":"","title":"Automatic Parameter Tagging"},{"location":"quickstart/#enabling-parameter-tagging","text":"You can configure the Opentracing Decorator to automatically tag function Spans with the names and values of the function arguments. To clarify, if we have a function like this 1 2 3 @tracing . trace ( operation_name = \"GetData\" ) def get_data ( method , url , headers = {}): return requests . request ( method , url , headers = headers ) we may want to see the values for method , url , and headers in our Span tags. Simply set the tag_parameters flag on the decorator. 1 2 3 4 5 # examples/automatic_parameter_tagging.py @tracing . trace ( operation_name = \"GetData\" , tag_parameters = True ) def get_data ( method , url , headers = {}): return requests . request ( method , url , headers = headers ) Now our function parameters are tagged and added to the span.","title":"Enabling parameter tagging"},{"location":"quickstart/#adding-a-tag-prefix","text":"You can set a tag prefix by using the parameter_prefix argument to the decorator. 1 2 3 @tracing . trace ( operation_name = \"GetData\" , tag_parameters = True , parameter_prefix = 'devops' ) def get_data ( method , url , headers = {}): return requests . request ( method , url , headers = headers ) This will put devops.* in front of every automatically tagged parameter. This is useful for avoiding collisions with tags from other applications.","title":"Adding a tag prefix"},{"location":"quickstart/#automatic-return-value-logging","text":"","title":"Automatic Return Value Logging"},{"location":"quickstart/#enabling-return-value-logging","text":"You can configure the Opentracing Decorator to automatically log function return values to the Span. To clarify, if we have a function like this 1 2 3 @tracing . trace ( operation_name = \"GetData\" ) def get_data ( method , url , headers = {}): return requests . request ( method , url , headers = headers ) we may want to see log the return value from the api request to our Span for future analysis. Simply set the tag_parameters flag on the decorator. 1 2 3 4 5 # examples/automatic_return_value_logging.py @tracing . trace ( operation_name = \"GetTime\" , log_return = True ) def get_time (): return time . time () Now our function return value is logged to the Span.","title":"Enabling return value logging"},{"location":"quickstart/#adding-a-return-prefix","text":"You can set a return prefix by using the return_prefix argument to the decorator. 1 2 3 @tracing . trace ( operation_name = \"GetTime\" , log_return = True , return_prefix = 'devops.return' ) def get_time (): return time . time ()","title":"Adding a return prefix"}]}